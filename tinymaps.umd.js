(function(a,c){typeof exports=="object"&&typeof module<"u"?c(exports):typeof define=="function"&&define.amd?define(["exports"],c):(a=typeof globalThis<"u"?globalThis:a||self,c(a.tinymaps={}))})(this,function(a){"use strict";var I=Object.defineProperty;var T=(a,c,m)=>c in a?I(a,c,{enumerable:!0,configurable:!0,writable:!0,value:m}):a[c]=m;var o=(a,c,m)=>(T(a,typeof c!="symbol"?c+"":c,m),m);class c{constructor(e,t){o(this,"topLeft");o(this,"bottomRight");if(!e)throw new Error("Top left point is required in bounds");if(!t)throw new Error("Bottom right point is required in bounds");if(e.x>t.x)throw new Error("Top left x must be less than bottom right x");this.topLeft=e,this.bottomRight=t}}function m(h){return h==null}function w(h){return typeof h!="number"||isNaN(h)}class d{constructor(e,t){o(this,"x");o(this,"y");if(w(e)||w(t))throw new Error("Invalid point coordinates");this.x=e,this.y=t}}class _{constructor(e,t){o(this,"latitude");o(this,"longitude");if(m(e)||m(t))throw new Error("Latitude and longitude must be provided");if(w(e)||w(t))throw new Error("Latitude and longitude must be numbers");if(e<-90||e>90)throw new Error("Latitude must be between -90 and 90");if(t<-180||t>180)throw new Error("Longitude must be between -180 and 180");this.latitude=e,this.longitude=t}}class g{project(e){if(!e)throw new Error("LatLon is required in projection");return new d(0,0)}unproject(e){if(!e)throw new Error("Point is required in projection");return new _(0,0)}}class x extends g{project(e){if(!e)throw new Error("LatLon is required in projection");const t=6378137,i=Math.PI/180,s=85.0511287798,n=Math.max(Math.min(e.latitude,s),-s),r=Math.sin(n*i),l=t*e.longitude*i,u=t*Math.log((1+r)/(1-r))/2;return new d(l,u)}unproject(e){if(!e)throw new Error("Point is required in unprojection");const t=6378137,i=180/Math.PI,s=e.x*i/t,n=(2*Math.atan(Math.exp(e.y/t))-Math.PI/2)*i;return new _(n,s)}}class b{constructor(e){o(this,"_center");o(this,"_zoom");o(this,"_tileSize");o(this,"_mapBounds");o(this,"_element");o(this,"_projection");o(this,"layers",[]);o(this,"interactives",[]);o(this,"_width");o(this,"_height");o(this,"_radius",6378137);if(!e.elementId)throw new Error("Element ID is required");if(!e.center)throw new Error("Center is required");if(!e.zoom||e.zoom<0||e.zoom>20)throw new Error("Zoom is required and should be between 0 and 20");this._projection=new x,this._center=this._projection.project(e.center),this._zoom=e.zoom,this._mapBounds=null,this._tileSize=256;const t=document.getElementById(e.elementId);if(!t)throw new Error("Element not found");this._width=t.clientWidth,this._height=t.clientHeight,this.calculateBounds(),this._element=t}get projection(){return this._projection}get zoom(){return this._zoom}set zoom(e){this._zoom=e,this.calculateBounds();for(const t of this.layers)t.update()}get center(){return this._projection.unproject(this._center)}get centerWorld(){return this._center}get width(){return this._width}get height(){return this._height}get element(){return this._element}get bounds(){if(!this._mapBounds)throw new Error("Map bounds not set");return this._mapBounds}set centerWorld(e){this._center=e,this.calculateBounds();for(const t of this.layers)t.update()}set center(e){this._center=this._projection.project(e),this.calculateBounds();for(const t of this.layers)t.update()}set tileSize(e){this._tileSize=e}addAttribution(e){const t=document.createElement("div");t.classList.add("attribution"),t.innerHTML=e,this._element.appendChild(t)}calculateResolution(){const e=2*Math.PI*this._radius,i=Math.pow(2,this._zoom)*this._tileSize;return e/i}calculateBounds(){const e=this.calculateResolution(),t=this._width/2*e,i=this._height/2*e,s=this._center.x-t,n=this._center.y-i,r=this._center.x+t,l=this._center.y+i;this._mapBounds=new c(new d(s,l),new d(r,n))}add(e){e.addLayer(this),this.layers.push(e)}attach(e){e.setMap(this),this.interactives.push(e)}degreesToRadians(e){return e*Math.PI/180}pixelToPoint(e){if(!this._mapBounds)throw new Error("Map bounds not set");const t=this._mapBounds.topLeft,i=this._mapBounds.bottomRight,s=(i.x-t.x)/this._width,n=(t.y-i.y)/this._height,r=e.x*s+t.x,l=t.y-e.y*n;return new d(r,l)}pointToPixel(e){if(!this._mapBounds)throw new Error("Map bounds not set");const t=this._mapBounds.topLeft,i=this._mapBounds.bottomRight,s=this._width/(i.x-t.x),n=this._height/(t.y-i.y),r=(e.x-t.x)*s,l=(t.y-e.y)*n;return new d(Math.round(r),Math.round(l))}}class M{constructor(e,t){o(this,"_topLeft");o(this,"_bottomRight");this._topLeft=e,this._bottomRight=t}get topLeft(){return this._topLeft}get bottomRight(){return this._bottomRight}}class f{constructor(e){o(this,"id");o(this,"canvas");o(this,"canvasContext");o(this,"zoom");o(this,"map");if(m(e))throw new Error("Layer id cannot be empty");this.id=e,this.zoom=1,this.map=null,this.canvas=null,this.canvasContext=null}update(){this.zoom=this.map.zoom,this.canvasContext.clearRect(0,0,this.map.width,this.map.height)}addLayer(e){if(!e)throw new Error("Map is required");this.map=e,this.canvas=document.createElement("canvas"),this.canvas.id=this.id,this.map.element.appendChild(this.canvas),this.canvas.width=e.width,this.canvas.height=e.height,this.canvasContext=this.canvas.getContext("2d"),this.zoom=e.zoom}removeLayer(){if(!this.map)throw new Error("Map is not set");this.map.element.removeChild(this.canvas),this.map=null,this.canvas=null,this.canvasContext=null}}class y{constructor(e=30){o(this,"_collection",[]);o(this,"_maxAmount",30);this._maxAmount=e}get(e){return this._collection.find(t=>t.id===e)}add(e){this._collection.length>=this._maxAmount&&this._collection.shift(),this._collection.push(e)}clear(){this._collection=[]}}class P extends f{constructor(t){super(t.id);o(this,"_tileUrl");o(this,"_tileSize");o(this,"_attribution");o(this,"_tileBuffer",new y);this._tileSize=t.tileSize||256,this._tileUrl=t.tileUrl,this._attribution=t.attribution||""}addLayer(t){super.addLayer(t),this.map&&(this.map.tileSize=this._tileSize,this.map.calculateBounds(),this.drawTiles(),this._attribution&&this.map.addAttribution(this._attribution))}removeLayer(){super.removeLayer(),this._tileBuffer.clear()}update(){super.update(),this.drawTiles()}drawTiles(){const t=this.getTileBounds();for(let i=t[0];i<=t[1];i++)for(let s=t[2];s<=t[3];s++){const n=this.getTileUrl(i,s,this.zoom);this.drawTile(n,i,s)}}getTileBounds(){if(!this.map)throw new Error("Map is not set");const t=Math.pow(2,this.zoom),i=Math.floor((this.map.bounds.topLeft.x+2003750834e-2)/(2*2003750834e-2)*t),s=Math.floor((this.map.bounds.bottomRight.x+2003750834e-2)/(2*2003750834e-2)*t),n=(Math.PI/2-2*Math.atan(Math.exp(-this.map.bounds.topLeft.y/6378137)))*(180/Math.PI),r=(Math.PI/2-2*Math.atan(Math.exp(-this.map.bounds.bottomRight.y/6378137)))*(180/Math.PI),l=Math.floor((1-Math.log(Math.tan(n*Math.PI/180)+1/Math.cos(n*Math.PI/180))/Math.PI)/2*t),u=Math.floor((1-Math.log(Math.tan(r*Math.PI/180)+1/Math.cos(r*Math.PI/180))/Math.PI)/2*t);return[Math.max(0,i),Math.max(0,s),Math.max(0,l),Math.max(0,u)]}getTileUrl(t,i,s){if(m(t)||m(i)||m(s))throw new Error("Invalid tile coordinates");return this._tileUrl.replace("{x}",t.toString()).replace("{y}",i.toString()).replace("{z}",s.toString())}tileExtend(t,i){const s=2003750834e-2,n=s/this._tileSize/.5/Math.pow(2,this.zoom);return[t*this._tileSize*n-s,s-i*this._tileSize*n,(t+1)*this._tileSize*n-s,s-(i+1)*this._tileSize*n]}drawTileOnCanvas(t,i,s){if(!this.map||!this.canvasContext)return;const n=this.tileExtend(i,s),r=new d(n[0],n[1]),l=new d(n[2],n[3]),u=this.map.pointToPixel(r),p=this.map.pointToPixel(l);this.canvasContext.drawImage(t,u.x,u.y,p.x-u.x,p.y-u.y)}drawTile(t,i,s){const n=this._tileBuffer.get(`${this.zoom}-${i}-${s}`);if(n){this.drawTileOnCanvas(n.image,i,s);return}else{const r=new Image;r.crossOrigin="anonymous",r.src=t,r.onload=()=>{this._tileBuffer.add({id:`${this.zoom}-${i}-${s}`,image:r}),this.drawTileOnCanvas(r,i,s)}}}}class L extends f{constructor(t){super(t.id);o(this,"_markers",[]);t.markers&&(this._markers=t.markers)}addLayer(t){super.addLayer(t),this.drawLayers()}update(){super.update(),this.drawLayers()}drawLayers(){if(this._markers)for(const t of this._markers)this.drawMarker(t)}getRadiusPixels(t){if(t.endsWith("px"))return t=t.slice(0,-2),parseInt(t,10);if(t.endsWith("m"))return t=t.slice(0,-1),parseInt(t,10);throw new Error("Radius should end with 'px' or 'm'")}drawMarker(t){const i=t.radius||"10px",s=t.fillColor||"darkblue",n=t.borderColor||"white",r=this.map.projection.project(t.center),l=this.map.pointToPixel(r),u=this.getRadiusPixels(i),p=this.canvasContext;p.beginPath(),p.arc(l.x,l.y,u,0,2*Math.PI,!1),p.fillStyle=s,p.fill(),p.lineWidth=5,p.strokeStyle=n,p.stroke()}}class v extends f{constructor(t){super(t.id);o(this,"_imageUrl");o(this,"_imageData",null);o(this,"_projection",null);o(this,"_bounds",null);o(this,"_opacity",1);this._imageUrl=t.imageUrl,this._bounds=t.bounds,this._opacity=t.opacity||1}addLayer(t){super.addLayer(t),this._projection=t.projection,this._imageData=new Image,this._imageData.src=this._imageUrl,this._imageData.onload=()=>{this.update()}}update(){super.update(),this.drawImage()}drawImage(){if(!this.map)throw new Error("Map is not set");if(this._imageData){const t=this._projection.project(this._bounds.topLeft),i=this.map.pointToPixel(t),s=this._projection.project(this._bounds.bottomRight),n=this.map.pointToPixel(s);this.canvasContext.globalAlpha=this._opacity,this.canvasContext.drawImage(this._imageData,i.x,i.y,n.x-i.x,n.y-i.y),this.canvasContext.globalAlpha=1}}}class E extends f{constructor(t){super(t.id);o(this,"_coordinates",[]);o(this,"_width",2);o(this,"_fillColor","black");t.coordinates&&(this._coordinates=t.coordinates,this._width=t.width||2,this._fillColor=t.fillColor||"black")}addLayer(t){super.addLayer(t),this.drawLayers()}update(){super.update(),this.drawLayers()}drawLayers(){this._coordinates&&this.drawLine(this._coordinates)}drawLine(t){const i=this.canvasContext;i.strokeStyle=this._fillColor,i.lineWidth=this._width,i.beginPath();for(const s of t){const n=this.map.projection.project(s.center),r=this.map.pointToPixel(n);i.lineTo(r.x,r.y)}i.stroke()}}class z{constructor(){o(this,"map");o(this,"mapRect");o(this,"resolution");o(this,"isPanning");o(this,"lastPointerPos");this.map=null,this.mapRect=null,this.resolution=0,this.isPanning=!1,this.lastPointerPos=null,this.pointerDown=this.pointerDown.bind(this),this.pointerMove=this.pointerMove.bind(this),this.pointerUp=this.pointerUp.bind(this)}setMap(e){this.map=e,this.mapRect=this.map.element.getBoundingClientRect(),this.map&&this.map.element.addEventListener("pointerdown",this.pointerDown)}pointerDown(e){e.preventDefault(),this.resolution=this.map.calculateResolution(),this.isPanning=!0,this.lastPointerPos=new d(e.clientX-this.mapRect.left,e.clientY-this.mapRect.top),this.map.element.setPointerCapture(e.pointerId),this.map.element.addEventListener("pointermove",this.pointerMove),this.map.element.addEventListener("pointerup",this.pointerUp)}pointerMove(e){if(!this.isPanning||!this.lastPointerPos)return;e.preventDefault();const t=new d(e.clientX-this.mapRect.left,e.clientY-this.mapRect.top);this.handlePan(t)}handlePan(e){const t=new d((this.lastPointerPos.x-e.x)*this.resolution,(this.lastPointerPos.y-e.y)*this.resolution);this.map.centerWorld=new d(this.map.centerWorld.x+t.x,this.map.centerWorld.y-t.y),this.lastPointerPos=e}pointerUp(e){this.isPanning&&(this.isPanning=!1,this.map.element.releasePointerCapture(e.pointerId),this.map.element.removeEventListener("pointerup",this.pointerUp),this.map.element.removeEventListener("pointermove",this.pointerMove))}}class C{constructor(e){o(this,"map");o(this,"minZoom");o(this,"maxZoom");if(this.map=null,e){if(e.minZoom&&(e.minZoom<0||e.minZoom>20))throw new Error("minZoom must be between 0 and 20");if(e.maxZoom&&(e.maxZoom<0||e.maxZoom>20))throw new Error("maxZoom must be between 0 and 20");if(e.minZoom&&e.maxZoom&&e.minZoom>e.maxZoom)throw new Error("minZoom must be less than maxZoom");if(e.minZoom&&e.maxZoom&&e.minZoom===e.maxZoom)throw new Error("minZoom and maxZoom cannot be equal")}this.minZoom=e&&e.minZoom||0,this.maxZoom=e&&e.maxZoom||20,this.scroll=this.scroll.bind(this)}setMap(e){this.map=e,this.map&&this.map.element.addEventListener("wheel",this.scroll)}scroll(e){e.preventDefault();const t=e.deltaY>0?-1:1,i=this.map.zoom+t;i>=this.minZoom&&i<=this.maxZoom&&(this.map.zoom=i)}}a.BoundingBox=M,a.ImageLayer=v,a.LatLon=_,a.LineLayer=E,a.Map=b,a.MarkerLayer=L,a.Pan=z,a.Point=d,a.TileLayer=P,a.Zoom=C,Object.defineProperty(a,Symbol.toStringTag,{value:"Module"})});
